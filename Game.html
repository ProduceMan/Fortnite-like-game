<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Battle Royale Demo - Multi Weapons</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
  #hud {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: sans-serif;
    z-index: 10;
  }
  #healthBar { width: 200px; height: 20px; background: red; }
  #inventory { margin-top: 10px; }
</style>
</head>
<body>
<div id="hud">
  <div>Health: <span id="healthValue">100</span></div>
  <div id="healthBar"></div>
  <div id="inventory">Inventory: [Pistol]</div>
</div>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

// Scene, Camera, Renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,10,20);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableZoom = false;

// Lights
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(50,50,50);
scene.add(dirLight);

// Textures
const loader = new THREE.TextureLoader();
const grassTex = loader.load('https://threejs.org/examples/textures/grasslight-big.jpg');
grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
grassTex.repeat.set(25,25);

// Ground
scene.add(new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({map:grassTex}))).rotation.x=-Math.PI/2;

// Player
const player = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), new THREE.MeshStandardMaterial({color:0x0000ff}));
player.position.y=1; scene.add(player);

// Buildings
const buildingTex = loader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');
for(let i=0;i<10;i++){
  const bGeo = new THREE.BoxGeometry(3,Math.random()*6+3,3);
  const building = new THREE.Mesh(bGeo,new THREE.MeshStandardMaterial({map:buildingTex}));
  building.position.set(Math.random()*100-50,bGeo.parameters.height/2,Math.random()*100-50);
  scene.add(building);
}

// Trees
for(let i=0;i<15;i++){
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.3,2),new THREE.MeshStandardMaterial({color:0x8B4513}));
  const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5,4,8),new THREE.MeshStandardMaterial({color:0x006400}));
  leaves.position.y=3;
  const tree = new THREE.Group(); tree.add(trunk); tree.add(leaves);
  tree.position.set(Math.random()*100-50,0,Math.random()*100-50);
  scene.add(tree);
}

// Storm zone
let stormRadius=80;
const storm = new THREE.Mesh(new THREE.CylinderGeometry(stormRadius,stormRadius,10,64),
  new THREE.MeshBasicMaterial({color:0xff0000,wireframe:true,opacity:0.4,transparent:true}));
storm.position.y=5; scene.add(storm);

// Health
let health=100;
const healthBar=document.getElementById('healthBar');
const healthValue=document.getElementById('healthValue');
function updateHealth(dmg){ health=Math.max(0,health-dmg); healthValue.innerText=health; healthBar.style.width=health*2+'px'; }

// Inventory and weapons
const inventory=['Pistol','Shotgun','Rifle'];
let currentWeapon=0; // index
const inventoryDiv=document.getElementById('inventory');
function updateInventory(){ inventoryDiv.innerText='Inventory: ['+inventory[currentWeapon]+']'; }
updateInventory();
window.addEventListener('keydown', e=>{ if(['1','2','3'].includes(e.key)) { currentWeapon=parseInt(e.key)-1; updateInventory(); } });

// Player movement
const keys={};
window.addEventListener('keydown',e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup',e=>keys[e.key.toLowerCase()]=false);

// Bullets
const bullets=[];
window.addEventListener('mousedown',shootBullet);
function shootBullet(){
  let dmg=20,speed=1,spread=0;
  if(currentWeapon===1){ dmg=50; speed=0.8; spread=0.3; } // Shotgun
  if(currentWeapon===2){ dmg=35; speed=1.2; spread=0; } // Rifle
  const count = currentWeapon===1?5:1;
  for(let i=0;i<count;i++){
    const bullet=new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), new THREE.MeshBasicMaterial({color:0xffff00}));
    bullet.position.set(player.position.x,player.position.y+1,player.position.z);
    const dir=new THREE.Vector3(0,0,-1).multiplyScalar(speed);
    dir.x+= (Math.random()-0.5)*spread; dir.z+= (Math.random()-0.5)*spread;
    bullet.velocity=dir;
    bullet.damage=dmg;
    bullets.push(bullet); scene.add(bullet);
  }
}

// Enemies
const enemies=[];
for(let i=0;i<5;i++){
  const enemy=new THREE.Mesh(new THREE.BoxGeometry(1,2,1), new THREE.MeshStandardMaterial({color:0xff0000}));
  enemy.position.set(Math.random()*100-50,1,Math.random()*100-50); enemy.health=50;
  enemies.push(enemy); scene.add(enemy);
}

// Animate
function animate(){
  requestAnimationFrame(animate);

  // Move player
  if(keys['w']) player.position.z-=0.3;
  if(keys['s']) player.position.z+=0.3;
  if(keys['a']) player.position.x-=0.3;
  if(keys['d']) player.position.x+=0.3;

  // Camera follow
  camera.position.x=player.position.x; camera.position.z=player.position.z+20;
  camera.position.y=player.position.y+10; camera.lookAt(player.position);

  // Storm shrink
  if(stormRadius>10){ stormRadius-=0.01; storm.scale.set(stormRadius/80,1,stormRadius/80); }

  // Update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i]; b.position.add(b.velocity);
    for(let j=enemies.length-1;j>=0;j--){
      const e=enemies[j];
      if(b.position.distanceTo(e.position)<1){ e.health-=b.damage; if(e.health<=0){ scene.remove(e); enemies.splice(j,1); } scene.remove(b); bullets.splice(i,1); break; }
    }
    if(Math.abs(b.position.x)>100 || Math.abs(b.position.z)>100){ scene.remove(b); bullets.splice(i,1); }
  }

  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
